# 操作系统原理 学习笔记

参考：

视频教程

操作系统原理(北京大学 ）  https://www.bilibili.com/video/av9555596

浙江大学 操作系统原理  李善平  https://www.bilibili.com/video/av13165555



书籍

[操作系统概念第七版中文版[郑扣根译]](file\操作系统概念第七版中文版.pdf)

[自己动手写操作系统](file\自己动手写操作系统.pdf)



全英文网站

https://pdos.csail.mit.edu/6.828/2014/schedule.html



## 1.1操作系统导学

主讲教师：李善平 季江民 寿黎但

授课32学时  实验16学时

预修课程： C语言程序设计语言 数据结构  计算机组成原理



多看书，看懂书

理解-》质疑-》否定



## 1.2操作系统引论

### 操作系统是什么？

操作系统是管理计算机硬件的程序，为应用程序提供基础，并且充当计算机硬件和计算机用户的中介



操作系统的两大目标

​	执行用户程序，并且更易于解决用户问题

​	更便于使用计算机系统



1、从计算机系统组成观点：

​	操作系统是系统软件

​	计算机系统组成  

​		软件  应用软件 系统软件

​		硬件 输入、输出设备  存储器（内存） 中央处理器



2、从资源管理程序观点：

​	操作系统是系统资源的管理者

​	操作系统是系统资源管理程序，它用于控制和管理计算机系统的硬件和软件资源



​	计算机系统资源

​		软件：程序、数据  硬件： IO设备  存储器 处理器

​		操作系统模块：  文件系统  设备管理  存储器管理  处理器（CPU、进程）管理



3、从软件分词、扩充机器的观点：

​	操作系统是扩充裸机的第一层系统软件



4、从服务用户的观点：

​	操作系统是用户和计算机硬件之间的接口

​		系统提供的接口有两累

​			命令级接口：提供了一组键盘或鼠标命令

​			程序级接口：提供了一组系统调用System Calls，即os中功能，供用户程序和其他程序调用



5、内核Kernal --  the one program running at all times on the computer (all else being application  programs)

​	在全时运行的一个程序



### 操作系统定义

操作系统是一组有效控制和管理计算机系统的硬件和软件资源，合理地组织计算机工作流程以及方便用户的程序组合。

​		有效：系统效率和资源利用率高

​		合理：公平、不公平则会产生死锁或者饥饿

​		方便：提供良好的用户界面、编程接口



计算机硬件系统结构

​	主机型：这类计算机以存储器为中心，CPU和各种通道都与存储器相连

​			以CPU和内存为核心

![](os_images\host_base.jpg)

​	总线型：微型计算机是以总线为纽带构成计算机系统，中央处理器、存储器、IO设备都挂载在总线

​		驱动程序，管理IO设备

![](os_images\bus_structure.jpg)





### 中断

中断是指CPU对系统中发生的异步事件的相应，异步事件是无一定时序关系的随机发生的事件



发生中断时正在执行的程序的暂停点称为中断断点

处理器暂停当前程序转而处理中断的过程称为中断响应

中断处理结束之后恢复原来程序的执行被称为中断返回

一个计算机系统提供的中断源的有序组合一般被称为中断字，这是一个逻辑结构，在不同的处理器有着很不相同的实现方式



中断一般可以分为硬件中断和软件中断两大类

硬件中断又可以分为硬件故障中断、输入输出中断和外部中断

软件中断（异常）又可以分为程序中断（例如定点操作数溢出，地址越界、虚拟内存管理中缺页等）和访管中断（trap陷入）

​	访管中断是用户程序在运行中请求操作系统为其提供服务而执行一条方管指令所引起的中断，又称为软件中断，系统调用。访问中断是进程所期待的，他是主动发起的中断，其他几种中断不是运行进程所期待的，它属于强迫性中断事件。



现代操作系统是中断驱动的 An operating system is interrupt driven



### 特权指令和非特权指令

特权指令：不允许用户程序中直接使用的指令。例如IO指令，设置时钟、设置寄存器等指令都是特权指令



非特权指令：用户程序中所使用的指令





### 两种运行状态

用户态 user model  ： 执行用户程序时

内核态 kernel model：执行操作系统程序时



![](os_images\kernel_to_user.jpg)





#### 内核态和用户态的区别

内核态

​	能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备

​	操作系统内核程序运行在内核下

​	使用内核栈



用户态

​	只能访问属于它的存储空间和普通寄存器，只能执行普通命令

​	用户程序以及操作系统核外服务程序运行在用户态下

​	使用用户栈





QA：普通寄存器是什么？



### 操作系统特征

​	并发性

​		并行 ： 指两个或多个事件在同一时刻发生

​		并发：指两个或多个在同一时间间隔内发生

​	共享性 Sharing

​	虚拟性Virtual

​	异步性 Asynchronism



​	其他特征

​		微内核结构

​		宏（单）内核结构

​		多线程  多核

​		对称处理机分布式操作系统

​		面向对象设计



### 操作系统功能部件

​	进程管理 Process Management

​	主存管理 Main Memory Management

​	文件管理 File Management

​	I/O系统管理  I/O System Management

​	二级储存器管理  Secondary Management

​	网络处理  Networking

​	保护系统  Protecting System

​	命令解释系统 Command-Interpreter System



### 操作系统类型

按功能分（早期）

​	批处理系统 Batch System

​	分时系统 Time Sharing System

​	实时系统 Real-Time System

按同时使用系统的用户数和系统能同时运行的进程数分成：

​	单用户、单进程系统 DOS Windows 3.1

​	单用户、多进程系统 OS/2、Windows 7

​	多用户、多进程系统  Linux 、Windows Server

按计算机系统（硬件）操作系统分成

​	微机操作系统 MS-DOS Windows系列 OS/2 SCO UNIX 、Linux等

​	网络操作系统 Unix 、Linux、Windows 2003/2008/2012 server

​	分布式操作系统

​	主机（mainframe）操作系统：AIX、HP-Unix、Linux

​	嵌入式操作系统

​	传感器节点操作系统 Sensor Node Operating Systems

​	智能卡操作系统 Smart Card Operating System

​	智能手机操作系统



Windows的历史沿革

![](os_images\windows_history.jpg)



Windows操作系统产品线

![](os_images\windows_product.jpg)



Unix大家庭

![](os_images\unix_family.jpg)



QA：

什么是GNU

各种开源协议有什么区别？

http://www.ha97.com/833.html



### 什么是Linux

Linux指的是Linux内核

Linux操作系统指的是GNU/Linux系统(基于Linux的GNU系统)

​	Linux系统的组成：内核，C库、编译器、工具集和系统的基本工具、各种硬件设备驱动程序 X Windows系统，登录程序，各种应用软件包括字处理软件、图形处理软件

​	Linux系统（发行版）：GNU软件28%+Linux 内核3%+其他部件。---www.gnu.org

Linux是一种类Unix的操作系统，Linux克隆了Unix，但不是Unix

Linux是遵守GNU的GPL协议的软件



超级计算机

​	

手持系统

​	个人数字助理 PersonalDigital Assistants (PDAs) Cellular telephone(手机)

​	嵌入式系统Embedded System

​	智能手机操作系统 IOS Android Symbian Windows Phone

计算机应用领域

几种主流嵌入式操作系统

​	嵌入式Linux 

​		RT-Linux

​		XLinux

​		红旗嵌入Linux

​	VxWorks

​	QNX

​	Windows CE

​	uC/OS

​	Palm OS

智能手机操作系统

​	IOS Android Symbian Windows Phone

​		

## 1.3操作系统结构

### 操作系统服务

用户接口 ： 

​		命令行接口  CLI

​		图形用户接口 GUI

​		批处理Batch

程序执行  调入一个程序进入内存并运行之的系统能力

I/O操作   由于用户程序不能直接执行I/O操作，操作系统必须提供完成I/O操作的手段

文件系统操纵 程序能够读、写、创建和删除文件

通信  运行的进程间再同一计算机或由网络连接的不同系统中交换信息。通过共享存储器或消息传递实现

出错检测：通过探测CPU与内存硬件中，在I/O设备中 或在用户程序中的错误，确保正确运算

资源分配：把资源分配给多个用户或多个同时运行的作业

记账：跟踪和记录用户对资源的使用，用于账单和统计

保护： 确保对资源的访问均在控制中



操作系统与用户接口

​	命令接口 Command Interface

​	程序接口 Program Interface （系统调用）



命令接口

​	命令行用户接口、文本界面、图形用户接口

命令行用户界面 Command User Interface CUI

​	键盘输入 DOS Linux UNiX

图形用户界面 Graphic User Interface GUI

​	鼠标输入

​	MacOS OS/2 Windows Linux等

程序接口

​	系统调用（System Calls) 、API 应用程序接口

QA：系统调用和API的区别？

系统调用就是一种特殊的接口。通过这个接口，用户可以访问内核空间。系统调用规定了用户进程进入内核的具体位置。

api 就是应用程序接口，是一些预定义的函数。跟内核没有必然的联系。

一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。





### 系统调用

系统调用提供了进程和操作系统之间的接口

​	这些调用通常以汇编语言指令的形式提供

​	有些语言（C、C++和Perl）已经取代了汇编语言而直接用于系统编程



向操作系统传递参数通常有三种方法

​	通过寄存器来传递参数，参数数量可能比寄存器多
​	将参数存放在内存的块或表中，并将块的地址作为参数传递给寄存器   指针 
​	把参数放在堆栈中，并通过操作系统弹出堆栈 不限制所传递参数的数量或长度	



系统调用是内核向用户进程提供服务的唯一方法，应用程序调用操作系统提供的功能模块（函数）。

用户程序通过系统调用从用户态切换到内核态，从而可以访问相应的资源。

这样做的好处是：

​	为用户控件提供一个硬件的抽象接口，使编程更加容易

​	有利于系统安全

​	有利于每个进程度运行在虚拟系统中，接口统一由利于移植



系统调用的类型

​	进程控制 结束、中止、装入、运行、创建、终止进程等

​	文件管理 创建文件、删除文件、打开、关闭文件等

​	设备管理 请求设备、释放设备、读、写、重定位设备等

​	信息维护  读取时间或日期、设置时间或日期等

​	通信   创建、删除通信连接、发送、接受消息、传递状态信息



应用编程接口（API）其实是一组函数定义，这些函数说明了如何获得一个给定的服务；而系统调用是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapper routine，唯一的目的就是发布系统调用），一些API应用了封装例程。

API还包含各种编程接口，如：C库函数

OpenGL编程接口等

系统调用的实现是在内核完成的，而用户态的函数是在函数库实现的



应用程序                          C库                                           内核

调用printf  -》 C库中的printf  C库中的write -》sys_write() 系统调用

printf有一部分运行在 用户态下，一部分运行在 内核态下





### 操作系统的设计

​	操作系统设计有着不同于一般应用系统设计的特征

​		复杂程度高

​		研制周期长

​		正确性难以保证  

​			最早的Unix是1400行代码，Windows xp有4000万行代码、fedroa core有2亿行代码，Linux kernel 3.1 有1700万行代码



解决途径：

​	良好的操作系统结构

​	先进的开发方法和工程化的管理方法（软件工程）

​	高效的开发工具



操作系统的设计考虑

​	功能设计：操作系统应具备哪些功能

​	算法设计：选择和设计满足系统功能的算法和策略，并分析和估算其效能

​	结构设计：选择合适的操作系统结构

按照系统的功能结构和特性要求，选择合适的结构、使用相应的结构设计方法将系统逐步的分解，抽象和综合。使操作系统结构清晰、简单、可靠、易读、而且使用方便、适用性强



几种常见的操作系统结构

​	简单结构  MS-DOS 利用最小的空间提供最多的功能 

![](os_images\ms-dos_structure.jpg)

​	层次化结构  

​			分层法的主要优点是模块化。选择了分层，这样每层都能利用底层的功能、操作和服务。

​			分层效率比较差

![](os_images\unix_structure.jpg)

​	单（宏）内核结构

​			宏内核 ，与微内核想法，宏内核是构建系统内核的传统方法。在这种方法中，内核的全部代码、包括所有子系统（如内存管理、文件系统、设备驱动程序）都打包到一个文件中。内核的每个函数都可以访问内核中所有其他部分。如果编程不小心，很可能导致源代码出现复杂的嵌套。

​	微内核

​		这种方法将所有非基本部分从内核移走，并将它们当做系统级程序和用户级程序来实现。

​		用户之间采用消息传递的方式来通信

​		优点：

​			易于扩展 

​			易于提升OS至一个新的体系结构 

​			更可靠 

​			更安全

​		缺点：

​			用户控件

​			效率低 与内核空间的通信代价较高  2个用户程序需要通过内核空间来通信

![](os_images\windows_kernel.jpg)

​	模块（Module）

​		许多现在操作系统实现内核模块（kernel Modules）

​			用面向对象的方法

​			内核的组成部分相互分离

​			任务之间的交互通过已知的接口来实现

​			每个模块在内核中是按照需要可装载的

​	模块类似于分层，但模块更具有灵活性

​		Linux Solaris Mac OS





​	虚拟机

​		虚拟机采用分层的方法，将物理硬件和OS内核统一看做为硬件。

​		虚拟机提供了于基本硬件相同的接口

​		通过利用CPU调度和虚拟内存技术，操作系统能创建一种幻觉、以至于进程认为有自己的处理器和自己的虚拟内存

​		物理计算机共享资源以创建虚拟机

​			CPU调度能共享出CPU造成一种每个用户都有自己的处理器的感觉

​			假脱机和文件系统能提供虚拟读卡机和虚拟行式打印机

​			一个普通的用户分时终端提供虚拟机操作员终端的功能

​	VMWare VirtualBox Microsoft Virtual PC

​		优缺点：

​				通过完全包含系统资源，虚拟机提供了一个坚实的安全屋

​				虚拟机允许进行系统开发而不必终端正常的系统操作

​				但虚拟机概念很难提供真实的硬件效果

![](os_images\virtual_machine.jpg)





## 2.1进程概念

李善平



![](os_images\cpu_io_process.jpg)

所有程序的执行都是CPU、I/O 交替执行   所以CPU达不到100%

所有程序输入、输出必须有一个



![](os_images\idea_muti_task.jpg)



历史原因：IO设备闲 无所谓

60年代的CPU很大，占地，水、电、空调，所以希望cpu利用率高，保证资源高效运转

一个操作系统执行了多个程序，为描述不同程序，诞生了进程



为什么不能沿用“程序”，为什么叫“进程”？

同一程序有不同的数据

不同程序有相同的数据



Process -》 a program in execution ; 在执行中的程序

​			process execution must progress in sequential fashion



进程三个维度   执行中的程序

1、执行什么程序维度

2、处理什么数据

3、描述状态维度 



Process include

​	program counter 当前执行位置

​	Stack   伴随的数据

​	data section  伴随的数据





### 内存中的进程Image实例

C语言编译后会生成不同的数据段  进程的映像

![](os_images\memory_image.jpg)



局部变量  进入 stack   ，执行完毕后退出 

共享变量、全局变量、静态变量  其他的公共数据段

malloc 动态申请内存空间  进入 heap



### 进程控制块 (PCB) 

Process Control Block 



进程通常跟以下信息关联

Process state    5种状态

Program number 进程号 不重复 正整数

Program counter   程序计数器  中央处理器中的寄存器，用于指示计算机在其程序序列中的位置

CPU registers  通用的寄存器

CPU scheuling infomation  CPU调度 依赖数据 上百字节

Memory-management infomation  所有和内存相关的变量 上百字节

Accounting infomation   记账信息 打开文件个数 占用cpu时间 占用内存等

I/O status infomation   所有设备的运行状态信息

#### 

本质是一种结构 比较复杂 CPU调度 依赖

每个进程都有一个pcb，一对一关系   几千字节  尽量小 驻留在内存

共享信息不要放PCB ，PCB只有独占信息



内存访问速度是纳秒级（10的-9次方），硬盘的访问速度是微秒级（10的-3次方）



![](os_images\pcb_example.png)

proce









![](os_images\process_status.jpg)

​	



### 进程状态

进程执行过程中，变化着状态

new   起始状态 进程被创建 

ready  就绪状态  进程准备就绪，等待分配一个CPU来解释执行

waiting 等待状态 进程等待某个事件发生   等待IO  等待进程间通信

running 执行状态   进程的代码正在解释 CPU工作

terminated  终止状态 进程被终止执行



### 进程调度队列

Job quene   等待进入计算机系统的待处理任务

Ready quene  进程就绪队列  驻留内存，准备就绪，等待CPU

Device quene 等待I/O设备的进程



等待队列 等待的资源不一样 按不同资源划分队列

![](os_images\ready_io_quene.png)

进程一经创建，即在这些对垒直接迁移，直至被终止



![](os_images\process_migration.png)



### 进程上下文切换 （Context Switch）

CPU任何时候只能为一个进程服务

当CPU转向为另外一个进程服务时，有雨CPU内部资源有限，它必须保存原有（转换前）进程的状态、装入待服务（转换后）进程的状态，也即“进程上下文切换”

状态 指寄存器、标志位、堆栈等当前值

上下文切换时间是一种额外开销（overhead），因为期间CPU不对用户进程做直接有益的事

上下文切换时间决定于CPU硬件支持力度



进程为了快速处理，希望变量放置寄存器，或内存中

[寄存器为什么比内存快？](http://www.ruanyifeng.com/blog/2013/10/register.html)

![](os_images\process_context_switch.png)





## 2.2 进程操作与进程通信

进程操作

### 进程创建

​	父进程创建若干子进程：后者再创建其子进程：与此类推，构成了反应传承关系的一颗进程树



子进程的资源

​	子进程共享父进程的所有资源

​	子进程共享父进程的部分资源

​	子进程不从父进程共享资源，重新独立申请



执行代码的执行顺序

​	父进程和子进程并发执行

​	父进程在子进程执行期间等待，待子进程执行完毕后才恢复执行余下代码

![](os_images\fork_child.png)





![](os_images\unix_fork.png)



### 进程终止

进程终止语义之一 子进程执行完最后一条执行后，要求操作系统将自己杀出(exit)，语义动作含：

​	子进程穿点数据给父进程（通过父进程的wait操作）

​	子进程的资源被操作系统收回



进程终止的语义之二 父进程终止子进程的执行（about），终止原因可能是：

​	子进程超额使用系统资源

​	早前交给子进程执行的任务，过期无效了



如果父进程终止了，它的子进程怎么办？

​	有些操作系统把这些子进程也全部终止



### 进程间合作

独立进程不会影响其他进程的执行，也不会影响

合作进程影响其他进程、或者受其影响

进程间合作是必须的，带来的好处

​	共享信息

​	加速（计算）执行任务

​	模块化

​	方便调用、等等。。。



### 进程间通信的方法

signal

管道

共享内存

消息传递



生产者进程生成信息，存储在缓冲区，供消费者进程消费

​	unbounded-buffer 缓冲区的容量无限

​	bounded-buffer 缓冲区的容量有限  一般都有限

![](os_images\bounded_buffer.png)



### Interprocess Communication (IPC)

send 发送消息给邮件服务器A

receive 从邮件服务器A接收消息



### 同步通信 VS 异步通信

同步通信   TCP协议  传输安全

​	发送操作send：发送进程等待，直至接受进程确认消息

​	接受操作receive：接收进程等待，直到有个消息到达



异步通信 UDP协议  性能好

​	发送操作send：发送进程发出消息后立即返回，不理会消息是否送达

​	接受操作receive：接收进程执行一次接收动作，要么有一条有效消息，要么收到空消息



​	



