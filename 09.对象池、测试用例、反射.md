### 对象池

使用buffered channel  实现对象池

```go
package obj_pool

import (
	"errors"
	"fmt"
	"testing"
	"time"
)

//资源结构体
type ReusableObj struct {
}

//对象池
type ObjPool struct {
	bufChan chan *ReusableObj //用于缓冲可存储对象
}

//生成对象池
func NewObjPool(numOfObj int) *ObjPool {
	objPool := ObjPool{}
	objPool.bufChan = make(chan *ReusableObj, numOfObj)
	for i := 0; i < numOfObj; i++ {
		objPool.bufChan <- &ReusableObj{} //生成资源对象 并放入对象池 channel
	}
	return &objPool
}

//从对象池中获取 对象
func (p *ObjPool) GetObj(timeout time.Duration) (*ReusableObj, error) {
	select {
	case ret := <-p.bufChan:
		return ret, nil
	case <-time.After(timeout): //超时控制   慢查询是遇到的很坏的情况
		return nil, errors.New("time out")
	}
}

//给对象池添加对象
func (p *ObjPool) ReleaseObj(obj *ReusableObj) error {
	select {
	case p.bufChan <- obj: //只能本对象才能插入队列
		return nil
	default:
		return errors.New("overflow")
	}
}

func TestObjPool(t *testing.T) {
	pool := NewObjPool(10)

	////尝试放置超过对象池数据的值
	//if err := pool.ReleaseObj(&ReusableObj{});err != nil{
	//	t.Error(err)
	//}


	for i := 0; i < 11; i++ {
		if v, err := pool.GetObj(time.Second * 1); err != nil {
			t.Error(err)
		} else {
			fmt.Printf("%T \n",v)
			//if err := pool.ReleaseObj(v); err != nil {
			//	t.Error(err)
			//}
		}
	}

	fmt.Println("done")
}
```



权衡 对象池 是否优化程序性能





## sync.Pool 对象缓存

尝试从私有对象获取

私有对象不存在，尝试从当前Processor的共享池获取

如果当前Processor共享池也是空的，那么久尝试去其他Processor的共享池获取

如果所有子池都是空的，最后就用用户指定的New函数尝试一个新的对象返回



Processor 包含  私有对象(线程安全) 共享池(协程不安全，需要锁)



sync.Pool对象的生命周期

GC会清除sync.pool缓存的对象

对象的缓存有效期为下一次GC之前



```go
package obj_cache

import (
	"fmt"
	"sync"
	"testing"
)

func TestSyncPool(t *testing.T){
	pool := &sync.Pool{
		New:func() interface{}{
			fmt.Println("Create a new Object!")
			return 100
		},
	}

	v := pool.Get().(int)
	fmt.Println(v)

	pool.Put(3)
	//runtime.GC() //GC会清除sync.pool中缓存的对象

	v1 , _ := pool.Get().(int)
	fmt.Println(v1)

	v2 , _ := pool.Get().(int)
	fmt.Println(v2)
}

func TestMutiSyncPool(t *testing.T){
	pool := &sync.Pool{
		New:func() interface{}{
			fmt.Println("Create a new Object!")
			return 10
		},
	}

	pool.Put(100)
	pool.Put(100)
	pool.Put(100)

	var wg sync.WaitGroup
	for i:=0;i<10;i++{
		wg.Add(1)
		go func(id int){
			t.Log(pool.Get())
			wg.Done()
		}(i)
	}

	wg.Wait()
}
```



适合于通过复用，降低复杂对象的创建和GC代价  不适合做连接池

协程安全，会有锁的开销

生命周期受GC影响，不适合于做连接池等，需自己管理生命周期的资源的池化  



权衡 锁的开销  还是创建的开销



## 测试相关

单元测试

```go
package testing

import "testing"

func square(a int) int{
	return a*a
}

func TestSquare(t *testing.T){
	inputs := [...]int{1,2,3}
	expected := [...]int{1,4,9}

	for i:=0;i<len(inputs);i++{
		ret := square(inputs[i])
		if ret!=expected[i] {
			t.Errorf("input is %d ,the expected is %d ,the actual %d",
				inputs[i],expected[i],ret)
		}
	}
}
```



内置单元测试框架

Fail Error 该测试失败，该测试继续，其他测试继续进行

FailNow ,Fatal 该测试失败 ，该测试中止，其他测试继续进行



代码覆盖率

go test -v -cover 



断言

https://github.com/stretchr/testify









## Benchmark

go test -bench=.

```go
package test

import (
	"bytes"
	"testing"
)

func BenchmarkAmount(b *testing.B){
	elems := [...]string{"1","2","3","4","5","6"}
	b.ResetTimer()
	for i:=0;i<b.N;i++{
		ret := ""
		for _,elem := range elems{
			ret += elem
		}
	}
	b.StopTimer()
}


func BenchmarkAmount2(b *testing.B){
	elems := [...]string{"1","2","3","4","5","6"}
	b.ResetTimer()
	for i:=0;i<b.N;i++{
		var buf bytes.Buffer
		for _,elem := range elems{
			buf.WriteString(elem)
		}
	}
	b.StopTimer()
}
```



```go
go test -bench . -benchtime 100000000x  -benchmem
goos: windows
goarch: amd64
BenchmarkAmount-8       100000000              195 ns/op              24 B/op          5 allocs/op
BenchmarkAmount2-8      100000000               92.5 ns/op            64 B/op          1 allocs/op
PASS
ok      _/D_/workspace_go/src/go_advanced/ch36/test     29.181s
```



## BDD 测试框架

Behavior Driven Development

让业务领域的专家参与开发

项目网站

https://github.com/smartystreets/goconvey



安装

go get -u github.com/smartystreets/goconvey/convey



启动WEB UI

$GOPATH/bin/goconvey

```go
package test

import (
	. "github.com/smartystreets/goconvey/convey"
	"testing"
)

func TestA(t *testing.T){
	Convey("Given 2 even numbers",t,func(){
		a := 2
		b := 4
		Convey("When add the tow numbers",func(){
			c := a+b
			Convey("Then the result is still even",func(){
				So(c%2,ShouldEqual,0)
			})
		})
	})
}

```





